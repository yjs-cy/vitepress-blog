# 日常类型

## 基本类型

- `string` - 字符串
- `number` - 数字
- `boolean` - 布尔值
- `Array<string>` 或 `string[]` - 字符串数组
- `Array<number>` 或 `number[]` - 数字数组

## any 类型

```typescript
let obj: any = { x: 0 };
obj.foo(); // TypeScript 不会报错，但运行时可能出错
```

**建议**：尽量少用，失去了类型检查的意义。

## 变量类型注解

```typescript
let myName: string = "Alice"; // 显式标注类型
let myName = "Alice"; // TypeScript 自动推断类型
```

通常让 TypeScript 自动推断就行，不用手动写类型。

## 函数类型

```typescript
// 参数类型注解
function greet(name: string) {
  console.log("Hello, " + name.toUpperCase());
}

// 返回值类型注解
function getFavoriteNumber(): number {
  return 26;
}

// 返回Promise的函数
async function getFavoriteNumber(): Promise<number> {
  return 26;
}
```

## 匿名函数自动推断

```typescript
const names = ["Alice", "Bob", "Eve"];
names.forEach(function(s) {
  console.log(s.toUpperCase()); // TypeScript 知道 s 是 string
});
```

## 对象类型

```typescript
// 定义对象形状
function printCoord(pt: { x: number; y: number }) {
  console.log(pt.x, pt.y);
}

// 可选属性
function printName(obj: { first: string; last?: string }) {
  // 当你从可选属性中读取数据时，你必须在使用它之前检查undefined。
  if (obj.last !== undefined) {
    // OK
    console.log(obj.last.toUpperCase());
  }
  // 现代js语法
  console.log(obj.last?.toUpperCase());
}
```

## 联合类型

```typescript
function printId(id: number | string) {
  console.log("Your ID is: " + id);
}

// 使用时要先检查类型
// 如果联合中的每个成员都有一个共同的属性，则可以使用该属性而不用缩小类型
function printId(id: number | string) {
  if (typeof id === "string") {
    console.log(id.toUpperCase());
  } else {
    console.log(id);
  }
}
```

## 类型别名

```typescript
// 给复杂类型起个简单名字
type Point = {
  x: number;
  y: number;
};

function printCoord(pt: Point) {
  // ...
}
```

## 接口

```typescript
// 跟类型别名很像
interface Point {
  x: number;
  y: number;
}
```

**接口 vs 类型别名**：大部分情况可以互换，接口更适合对象类型，因为始终可扩展。

## 类型断言

```typescript
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
```

告诉 TypeScript："相信我，我知道这个元素的类型"。

## 字面量类型

```typescript
// 只能是特定的值
let alignment: "left" | "right" | "center" = "left";
```

## null 和 undefined

TypeScript 严格检查这两种值，需要明确处理。

## 非空断言运算符（!）
在任何表达式之后写 ! 实际上是一个类型断言，该值不是 null 或 undefined
```typescript
function liveDangerously(x?: number | null) {
  // No error
  console.log(x!.toFixed());
}
```

## 核心要点总结

1. **TypeScript 的核心价值**：在代码运行前发现错误
2. **大部分情况**：让 TypeScript 自动推断类型，不用手动写
3. **关键思想**：通过描述数据的形状来检查代码是否正确
4. **从简单开始**：先用基本类型，慢慢学习高级特性
